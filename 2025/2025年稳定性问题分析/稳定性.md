# 轻文档稳定性问题治理体系

## 一、问题背景

- 使用 OT（Operational Transformation）协同技术
- 当前问题：数据错乱、丢数据
- 表现：用户看到的内容排版与浏览器底层存储数据不一致

---

## 二、问题分层模型

```
┌─────────────────────────────────────────────────────────┐
│                    用户感知层                            │
│  (排版错乱、内容丢失、光标跳动、卡顿)                      │
├─────────────────────────────────────────────────────────┤
│                    渲染层                                │
│  (DOM状态、Selection状态、虚拟DOM diff)                   │
├─────────────────────────────────────────────────────────┤
│                    编辑器状态层                          │
│  (文档模型、Undo/Redo栈、本地操作队列)                    │
├─────────────────────────────────────────────────────────┤
│                    协同层 (OT)                           │
│  (操作转换、版本控制、冲突解决)                           │
├─────────────────────────────────────────────────────────┤
│                    通信层                                │
│  (WebSocket、消息队列、ACK机制)                          │
├─────────────────────────────────────────────────────────┤
│                    存储层                                │
│  (服务端持久化、客户端IndexedDB/LocalStorage)            │
└─────────────────────────────────────────────────────────┘
```

---

## 三、核心稳定性保障机制

### 3.1 数据一致性保障

| 机制 | 描述 | 实现方式 |
|-----|------|---------|
| **版本向量** | 追踪每个客户端的操作版本 | 每个操作携带 `{clientId, revision}` |
| **操作幂等** | 相同操作多次执行结果一致 | 操作带唯一ID，服务端去重 |
| **快照校验** | 定期校验客户端与服务端数据一致性 | 每N次操作或M秒做一次 checksum 比对 |
| **强制同步** | 检测到不一致时的恢复机制 | 拉取服务端最新快照，重建本地状态 |

### 3.2 操作可靠性保障

```
客户端操作流程:
    
    用户输入
        │
        ▼
    生成 Operation (带唯一ID)
        │
        ├──────────────────┐
        ▼                  ▼
    本地立即应用        加入待确认队列
    (乐观更新)          (持久化到IndexedDB)
        │                  │
        │                  ▼
        │              发送到服务端
        │                  │
        │                  ▼
        │              等待 ACK
        │                  │
        │         ┌───────┴───────┐
        │         ▼               ▼
        │      收到ACK         超时/失败
        │         │               │
        │         ▼               ▼
        │    从队列移除        指数退避重试
        │                         │
        └─────────────────────────┘
```

### 3.3 渲染一致性保障

| 问题 | 检测方式 | 修复方式 |
|-----|---------|---------|
| DOM与模型不一致 | 定期对比 DOM 内容与文档模型 | 强制重新渲染 |
| Selection 状态异常 | 监听 selectionchange 事件 | 重置光标位置 |
| 虚拟DOM脏数据 | 状态变更后校验 | 强制 forceUpdate |

---

## 四、监控体系

### 4.1 核心指标

```
┌────────────────────────────────────────────────────────┐
│                     黄金指标                            │
├────────────────────────────────────────────────────────┤
│  1. 操作成功率 = 成功ACK数 / 总操作数                    │
│  2. 数据一致率 = 校验通过次数 / 总校验次数               │
│  3. 同步延迟 P99 = 操作发送到ACK的时间                   │
│  4. 冲突率 = 需要转换的操作数 / 总操作数                 │
│  5. 强制同步率 = 触发强制同步次数 / 总会话数             │
└────────────────────────────────────────────────────────┘
```

### 4.2 埋点设计

```javascript
// 关键埋点事件
const EVENTS = {
  // 操作层
  OP_CREATED: 'op_created',           // 操作生成
  OP_SENT: 'op_sent',                 // 操作发送
  OP_ACKED: 'op_acked',               // 操作确认
  OP_FAILED: 'op_failed',             // 操作失败
  OP_RETRIED: 'op_retried',           // 操作重试
  
  // 协同层
  OT_TRANSFORM: 'ot_transform',       // OT转换
  OT_CONFLICT: 'ot_conflict',         // OT冲突
  
  // 一致性
  CHECKSUM_PASS: 'checksum_pass',     // 校验通过
  CHECKSUM_FAIL: 'checksum_fail',     // 校验失败
  FORCE_SYNC: 'force_sync',           // 强制同步
  
  // 渲染层
  RENDER_MISMATCH: 'render_mismatch', // 渲染不一致
  SELECTION_RESET: 'selection_reset', // 光标重置
};
```

### 4.3 告警规则

| 指标 | 阈值 | 告警级别 |
|-----|------|---------|
| 操作成功率 | < 99.9% | P1 |
| 数据一致率 | < 99.99% | P0 |
| 同步延迟 P99 | > 500ms | P2 |
| 强制同步率 | > 1% | P1 |
| 操作重试率 | > 5% | P2 |

---

## 五、问题排查流程

```
用户反馈问题
      │
      ▼
┌─────────────────┐
│ 1. 收集现场信息  │
│  - 用户ID       │
│  - 文档ID       │
│  - 时间范围     │
│  - 操作序列     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 2. 日志分析     │
│  - 客户端日志   │
│  - 服务端日志   │
│  - 对比时间线   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 3. 定位问题层   │ ──→ 参考"问题分层模型"
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 4. 复现验证     │
│  - 构造测试用例 │
│  - 本地复现     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 5. 修复&验证    │
└─────────────────┘
```

---

## 六、防御性编程实践

### 6.1 操作层防御

```javascript
class OperationManager {
  // 操作前校验
  validateOperation(op) {
    // 1. 操作范围检查
    if (op.position < 0 || op.position > this.docLength) {
      this.reportError('INVALID_POSITION', op);
      return false;
    }
    // 2. 操作内容检查
    if (op.type === 'delete' && op.count > this.docLength - op.position) {
      this.reportError('DELETE_OVERFLOW', op);
      return false;
    }
    return true;
  }
  
  // 操作后校验
  verifyAfterApply(op, expectedLength) {
    if (this.docLength !== expectedLength) {
      this.reportError('LENGTH_MISMATCH', {op, expected: expectedLength, actual: this.docLength});
      this.triggerForceSync();
    }
  }
}
```

### 6.2 协同层防御

```javascript
class OTEngine {
  transform(op1, op2) {
    const result = this.doTransform(op1, op2);
    
    // 转换结果校验：应用顺序无关性
    // apply(apply(doc, op1), transform(op2, op1)) === apply(apply(doc, op2), transform(op1, op2))
    if (!this.verifyTransformProperty(op1, op2, result)) {
      this.reportError('OT_PROPERTY_VIOLATION', {op1, op2, result});
    }
    
    return result;
  }
}
```

### 6.3 存储层防御

```javascript
class StorageManager {
  async saveSnapshot(doc) {
    const snapshot = {
      content: doc.content,
      revision: doc.revision,
      checksum: this.calculateChecksum(doc.content),
      timestamp: Date.now(),
    };
    
    // 写入前校验
    const existing = await this.load(doc.id);
    if (existing && existing.revision >= snapshot.revision) {
      this.reportError('REVISION_REGRESSION', {existing, new: snapshot});
      return;
    }
    
    await this.storage.set(doc.id, snapshot);
    
    // 写入后验证
    const saved = await this.storage.get(doc.id);
    if (saved.checksum !== snapshot.checksum) {
      this.reportError('STORAGE_CORRUPTION', {expected: snapshot, actual: saved});
    }
  }
}
```

---

## 七、测试体系

### 7.1 测试金字塔

```
                    ┌───────────┐
                    │  E2E测试   │  多用户协同场景
                   ─┴───────────┴─
                 ┌─────────────────┐
                 │   集成测试       │  OT + 通信 + 存储
               ──┴─────────────────┴──
             ┌───────────────────────┐
             │      单元测试          │  OT转换函数、操作校验
           ──┴───────────────────────┴──
         ┌───────────────────────────────┐
         │        Fuzzing 测试            │  随机操作序列
       ──┴───────────────────────────────┴──
```

### 7.2 关键测试场景

| 场景 | 描述 | 验证点 |
|-----|------|-------|
| 并发编辑同一位置 | A和B同时在位置X插入文本 | 最终一致性、无数据丢失 |
| 网络分区 | 客户端离线编辑后重连 | 操作正确合并 |
| 快速连续输入 | 用户快速打字 | 操作不丢失、顺序正确 |
| 大文档操作 | 10万字文档的编辑 | 性能、内存稳定 |
| 断线重连 | WebSocket断开后恢复 | 状态正确恢复 |

---

## 八、应急预案

### 8.1 数据丢失应急

```
1. 立即行动
   - 停止问题用户的自动保存
   - 保留客户端 IndexedDB 数据
   
2. 数据恢复
   - 从服务端获取历史快照
   - 从客户端本地存储恢复
   - 合并操作日志重建
   
3. 根因分析
   - 收集所有相关日志
   - 复现问题
   - 修复并验证
```

### 8.2 大面积故障应急

```
1. 降级策略
   - 关闭实时协同，切换为单人编辑模式
   - 增加保存频率
   
2. 灰度恢复
   - 小流量验证修复
   - 逐步放开流量
```

---

## 九、持续改进

### 9.1 复盘模板

```markdown
## 问题复盘：[问题标题]

### 时间线
- HH:MM 发现问题
- HH:MM 开始排查
- HH:MM 定位原因
- HH:MM 修复上线
- HH:MM 验证通过

### 影响范围
- 影响用户数：
- 影响文档数：
- 数据丢失量：

### 根因分析
[5 Whys 分析]

### 改进措施
| 措施 | 负责人 | 截止日期 |
|-----|-------|---------|
|     |       |         |

### 经验教训
```

### 9.2 稳定性周报指标

- 本周操作成功率
- 本周数据一致率
- 本周问题数量 & 分类
- 本周改进措施完成情况

https://shimo.im/docs/Ee32mDozRZCjXOA2/ 《轻文档数据错乱的可能原因和应对方案》，可复制链接后用石墨文档 App 打开